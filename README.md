# bsv

Bitcoin SV JavaScript Library

## API

<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

##### Table of Contents

-   -   [aes](#aes)
-   [bsv](#bsv)
-   [Bitcoin Address](#bitcoin-address)
-   [Bip32: HD Wallets](#bip32-hd-wallets)
    -   [asyncFromString](#asyncfromstring)
        -   [Parameters](#parameters)
    -   [fromFastBuffer](#fromfastbuffer)
        -   [Parameters](#parameters-1)
    -   [toFastBuffer](#tofastbuffer)
    -   [asyncToString](#asynctostring)
-   [Bip39: Mnemonic Seeds](#bip39-mnemonic-seeds)
    -   [fromRandom](#fromrandom)
        -   [Parameters](#parameters-2)
    -   [entropy2Mnemonic](#entropy2mnemonic)
        -   [Parameters](#parameters-3)
    -   [check](#check)
    -   [mnemonic2Seed](#mnemonic2seed)
        -   [Parameters](#parameters-4)
-   [Big Number](#big-number)
    -   [fromSm](#fromsm)
        -   [Parameters](#parameters-5)
    -   [fromBits](#frombits)
        -   [Parameters](#parameters-6)
    -   [toBits](#tobits)
    -   [mod](#mod)
        -   [Parameters](#parameters-7)
    -   [umod](#umod)
        -   [Parameters](#parameters-8)
    -   [decorate](#decorate)
        -   [Parameters](#parameters-9)
-   [Buffer Reader](#buffer-reader)
-   [Bitcoin Signed Message](#bitcoin-signed-message)
-   [Buffer Writer](#buffer-writer)
-   [Base58 Encoding](#base58-encoding)
-   [Base58 Check Encoding](#base58-check-encoding)
-   [Block](#block)
    -   [iterateTxs](#iteratetxs)
        -   [Parameters](#parameters-10)
-   [Merkle](#merkle)
    -   [fromBufferArrays](#frombufferarrays)
        -   [Parameters](#parameters-11)
-   [Block Header](#block-header)
-   [Constants](#constants)
    -   [Error](#error)
-   [Ecdsa](#ecdsa)
    -   [deterministicK](#deterministick)
        -   [Parameters](#parameters-12)
    -   [sig2PubKey](#sig2pubkey)
    -   [calcrecovery](#calcrecovery)
        -   [Parameters](#parameters-13)
-   [Hash](#hash)
-   [Script Interpreter](#script-interpreter)
    -   [fromJSONNoTx](#fromjsonnotx)
        -   [Parameters](#parameters-14)
    -   [toJSONNoTx](#tojsonnotx)
    -   [checkSigEncoding](#checksigencoding)
        -   [Parameters](#parameters-15)
    -   [checkPubKeyEncoding](#checkpubkeyencoding)
        -   [Parameters](#parameters-16)
    -   [checkLockTime](#checklocktime)
        -   [Parameters](#parameters-17)
    -   [checkSequence](#checksequence)
        -   [Parameters](#parameters-18)
    -   [eval](#eval)
    -   [step](#step)
    -   [verify](#verify)
        -   [Parameters](#parameters-19)
    -   [results](#results)
        -   [Parameters](#parameters-20)
    -   [getDebugObject](#getdebugobject)
    -   [getFlags](#getflags)
        -   [Parameters](#parameters-21)
-   [KeyPair](#keypair)
-   [Point (on secp256k1)](#point-on-secp256k1)
-   [Private Key](#private-key)
    -   [toWif](#towif)
    -   [fromWif](#fromwif)
        -   [Parameters](#parameters-22)
-   [Public Key](#public-key)
    -   [fromDer](#fromder)
        -   [Parameters](#parameters-23)
    -   [isCompressedOrUncompressed](#iscompressedoruncompressed)
        -   [Parameters](#parameters-24)
-   [Random Number Generator](#random-number-generator)
    -   [fromBitcoindString](#frombitcoindstring)
        -   [Parameters](#parameters-25)
    -   [toBitcoindString](#tobitcoindstring)
    -   [fromAsmString](#fromasmstring)
        -   [Parameters](#parameters-26)
    -   [toAsmString](#toasmstring)
    -   [fromPubKeyHash](#frompubkeyhash)
        -   [Parameters](#parameters-27)
    -   [fromPubKeys](#frompubkeys)
        -   [Parameters](#parameters-28)
    -   [isPubKeyHashIn](#ispubkeyhashin)
    -   [isScriptHashIn](#isscripthashin)
    -   [findAndDelete](#findanddelete)
        -   [Parameters](#parameters-29)
-   [Signature](#signature)
    -   [Sig](#sig)
        -   [Parameters](#parameters-30)
        -   [hasLowS](#haslows)
        -   [hasDefinedHashType](#hasdefinedhashtype)
        -   [parseDer](#parseder)
            -   [Parameters](#parameters-31)
        -   [IsTxDer](#istxder)
            -   [Parameters](#parameters-32)
-   [PubKey Map](#pubkey-map)
    -   [setOne](#setone)
        -   [Parameters](#parameters-33)
    -   [setMany](#setmany)
        -   [Parameters](#parameters-34)
    -   [get](#get)
        -   [Parameters](#parameters-35)
-   [Structure](#structure)
    -   [genFromBuffers](#genfrombuffers)
    -   [expect](#expect)
        -   [Parameters](#parameters-36)
    -   [fromBuffer](#frombuffer)
        -   [Parameters](#parameters-37)
    -   [fromFastBuffer](#fromfastbuffer-1)
        -   [Parameters](#parameters-38)
    -   [toBuffer](#tobuffer)
        -   [Parameters](#parameters-39)
    -   [toFastBuffer](#tofastbuffer-1)
        -   [Parameters](#parameters-40)
-   [Transaction](#transaction)
    -   [sighash](#sighash)
        -   [Parameters](#parameters-41)
    -   [isCoinbase](#iscoinbase)
    -   [sort](#sort)
-   [Hash Cache](#hash-cache)
-   [Transaction Builder](#transaction-builder)
    -   [setNLocktime](#setnlocktime)
        -   [Parameters](#parameters-42)
    -   [setDust](#setdust)
        -   [Parameters](#parameters-43)
    -   [sendDustChangeToFees](#senddustchangetofees)
        -   [Parameters](#parameters-44)
    -   [importPartiallySignedTx](#importpartiallysignedtx)
        -   [Parameters](#parameters-45)
    -   [inputFromScript](#inputfromscript)
        -   [Parameters](#parameters-46)
    -   [inputFromPubKeyHash](#inputfrompubkeyhash)
        -   [Parameters](#parameters-47)
    -   [outputToAddress](#outputtoaddress)
        -   [Parameters](#parameters-48)
    -   [outputToScript](#outputtoscript)
        -   [Parameters](#parameters-49)
    -   [build](#build)
        -   [Parameters](#parameters-50)
    -   [getSig](#getsig)
        -   [Parameters](#parameters-51)
    -   [asyncGetSig](#asyncgetsig)
        -   [Parameters](#parameters-52)
    -   [signTxIn](#signtxin)
        -   [Parameters](#parameters-53)
    -   [asyncSignTxIn](#asyncsigntxin)
        -   [Parameters](#parameters-54)
    -   [allSigsPresent](#allsigspresent)
        -   [Parameters](#parameters-55)
    -   [removeBlankSigs](#removeblanksigs)
        -   [Parameters](#parameters-56)
    -   [fromPubKeyHashTxOut](#frompubkeyhashtxout)
        -   [Parameters](#parameters-57)
    -   [setNullInput](#setnullinput)
-   [Transaction Output](#transaction-output)
-   [Transaction Output Map](#transaction-output-map)
-   [Transaction Verifier](#transaction-verifier)
    -   [verify](#verify-1)
        -   [Parameters](#parameters-58)
    -   [checkStr](#checkstr)
    -   [verifyStr](#verifystr)
        -   [Parameters](#parameters-59)
    -   [verifyNIn](#verifynin)
        -   [Parameters](#parameters-60)
    -   [verify](#verify-2)
        -   [Parameters](#parameters-61)
-   [VarInt (a.k.a. Compact Size)](#varint-aka-compact-size)
-   [Workers](#workers)
-   [WorkersResult](#workersresult)
-   [Constant-Time Buffer Compare](#constant-time-buffer-compare)
-   [Ach (Aes+Cbc+Hmac) (experimental)](#ach-aescbchmac-experimental)
-   [Aes (experimental)](#aes-experimental)
-   [Aescbc (experimental)](#aescbc-experimental)
-   [Cbc](#cbc)
-   [Ecies](#ecies)

#### aes

### bsv

entry.js is the entry point for a the js bundlers.
Webpack and microbundlers, both start use this file as
the entry point to bundle the entire library.

#### 

### Bitcoin Address

A bitcoin address. Normal use cases:
const address = new Address().fromPubKey(pubKey)
const address = new Address().fromString(string)
const string = address.toString()
const script = address.toTxOutScript()
const isValid = Address.isValid(string)

Can also do testnet:
const address = Address.Testnet()

Note that an Address and an Addr are two completely different things. An
Address is what you send bitcoin to. An Addr is an ip address and port that
you connect to over the internet.

#### 

### Bip32: HD Wallets

Bip32 is hierarchical deterministic wallets. The standard way to use this is:
const bip32 = new Bip32().fromRandom()
const bip32 = new Bip32().fromSeed(buf)
const bip32 = new Bip32().fromString(string)
const xprv = bip32.toString()
const xpub = bip32.toPublic().toString()

This code was originally copied from here:

<https://github.com/sarchar/brainwallet.github.com>

It has faced mostly cosmetic alterations since it was copied.

#### asyncFromString

Use workers to convert a bip32 string into a bip32 object without
blocking.

##### Parameters

-   `str`  

#### fromFastBuffer

This is a faster version of .fromBuffer that reads in the output from
.toFastBuffer rather than from .toBuffer. .toFastBuffer outputs almost the
same thing as .toBuffer, except the public key is uncompressed. That makes
it larger, but also means that point multiplication doesn't have to be
used to derive the y value. So reading it in is faster. The only thing we
have to do is explicitely set the "compressed" value of public key to true
after reading it in. That is because although .toFastBuffer and
.fromFastBuffer transmit the public key in uncompressed form, we want it
to be set to compressed when stored in memory.

##### Parameters

-   `buf`  

#### toFastBuffer

This is the "fast" analog of toBuffer. It is almost the same as toBuffer,
and in fact is actually not any faster. The only difference is that it
adds an uncompressed rather than compressed public key to the output. This
is so that .fromFastBufer can read in the public key without having to do
fancy, slow point multiplication to derive the y value of the public key.
Thus, although .toFastBuffer is not any faster, .fromFastBuffer is faster.

#### asyncToString

Use workers to convert a bip32 object into a bip32 string without
blocking.

#### 

### Bip39: Mnemonic Seeds

Bip39 is a way to turn random entropy into a mnemonic (a string of words
from a wordlist), and then that mnemonic into a seed. The seed can then be
used in Bip32 to derive hierarchical deterministic keys. It does not go the
other way around (i.e., you cannot turn a seed into a mnemonic). The usual
way to use it is either to generate a new one, like this:

const mnemonic = new Bip39().fromRandom().toString()

or from a known mnemonic:

const seed = new Bip39().fromString(mnemonic).toSeed()

#### fromRandom

Generate a random new mnemonic from the wordlist.

##### Parameters

-   `bits`  

#### entropy2Mnemonic

Generate a new mnemonic from some entropy generated somewhere else. The
entropy must be at least 128 bits.

##### Parameters

-   `buf`  

#### check

Check that a mnemonic is valid. This means there should be no superfluous
whitespace, no invalid words, and the checksum should match.

#### mnemonic2Seed

Convert a mnemonic to a seed. Does not check for validity of the mnemonic -
for that, you should manually run check() first.

##### Parameters

-   `passphrase`   (optional, default `''`)

#### 

### Big Number

Since javascript numbers are only precise up to 53 bits, and bitcoin is
based on cryptography that uses 256 bit numbers, we must use a big number
library. The library we use at the moment is Fedor Indutny's bn.js library.
Since big numbers are extremely useful, we provide some very basic wrappers
for his big number class and expose it. The wrappers merely allow you to do,
say, bn.cmp(num) instead of just bn.cmp(bn), which is nice. The primary way
to use this is:
const bn = Bn(str) // str is base 10
const bn = Bn(num)
const bn = Bn().fromBuffer(buf)
const bn = Bn().fromSm(buf); // sign+magnitude format, first bit is sign

For little endian, pass in an options value:
const bn = Bn().fromBuffer(buf, {endian: 'little'})
const bn = Bn().fromSm(buf, {endian: 'little'})

Getting output:
const str = Bn().toString() // produces base 10 string
const buf = Bn().toBuffer() // produces buffer representation
const buf = Bn().toBuffer({size: 32}) //produced 32 byte buffer

#### fromSm

Signed magnitude buffer. Most significant bit represents sign (0 = positive,
1 = negative).

##### Parameters

-   `buf`  
-   `opts`   (optional, default `{endian:'big'}`)

#### fromBits

Produce a Bn from the "bits" value in a blockheader. Analagous to Bitcoin
Core's uint256 SetCompact method. bits is assumed to be UInt32.

##### Parameters

-   `bits`  
-   `opts`   (optional, default `{strict:false}`)

#### toBits

Convert Bn to the "bits" value in a blockheader. Analagous to Bitcoin
Core's uint256 GetCompact method. bits is a UInt32.

#### mod

to be used if this is positive.

##### Parameters

-   `bn`  

#### umod

to be used if this is negative.

##### Parameters

-   `bn`  

#### decorate

All the standard big number operations operate on other big numbers. e.g.,
bn1.add(bn2). But it is frequenly valuble to add numbers or strings, e.g.
bn.add(5) or bn.add('5'). The decorator wraps all methods where this would
be convenient and makes that possible.

##### Parameters

-   `name`  

#### 

### Buffer Reader

This is a convenience class for reading VarInts and other basic types from a
buffer. This class is most useful for reading VarInts, and also for signed
or unsigned integers of various types. It can also read a buffer in reverse
order, which is useful in bitcoin which uses little endian numbers a lot so
you find that you must reverse things. You probably want to use it like:
varInt = new Br(buf).readnew VarInt()

#### 

### Bitcoin Signed Message

"Bitcoin Signed Message" just refers to a standard way of signing and
verifying an arbitrary message. The standard way to do this involves using a
"Bitcoin Signed Message:\\n" prefix, which this code does. You are probably
interested in the static Bsm.sign( ... ) and Bsm.verify( ... ) functions,
which deal with a base64 string representing the compressed format of a
signature.

#### 

### Buffer Writer

This is the writing complement of the Br. You can easily write
VarInts and other basic number types. The way to use it is: buf =
new Bw().write(buf1).write(buf2).toBuffer()

#### 

### Base58 Encoding

Base58 (no check)

#### 

### Base58 Check Encoding

Base58 check encoding. The usual way to use it is
new Base58Check(buf).toString() or new Base58Check(str).toBuffer().

#### 

### Block

A block, of course, is a collection of transactions. This class is somewhat
incompconste at the moment. In the future, it should support the ability to
check to see if a transaction is in a block (thanks to the magic of merkle
trees). You will probably never use Yours Bitcoin to create a block, since almost
everyone will use bitcoind for that. As such, the primary way to use this is
new Block().fromBuffer(buf), which will parse the block and prepare its insides
for you to inspect.

#### iterateTxs

Sometimes we don't want to parse an entire block into memory. Instead, we
simply want to iterate through all transactions in the block. That is what
this method is for. This method returns an efficient iterator which can be
used in a `for (tx of txs)` construct that returns each tx one at a time
without first parsing all of them into memory.

##### Parameters

-   `blockBuf` **[Buffer](https://nodejs.org/api/buffer.html)** A buffer of a block.

#### 

### Merkle

A node in a Merkle tree (possibly the root node, in which case it is the
Merkle root). A node either contains a buffer or links to two other nodes.

#### fromBufferArrays

Takes two arrays, both of which _must_ be of a length that is a power of
two.

##### Parameters

-   `bufs1`  
-   `bufs2`  

#### 

### Block Header

Every block contains a blockHeader. This is probably not something you will
personally use, but it's here if you need it.

#### 

### Constants

Constants used to distinguish mainnet from testnet.

#### Error

Yours Bitcoin can be globally configured to mainnet or testnet. Via the
inject pattern, you always have access to the other network at any time.
However, it is very convenient to be able to change the default
configuration. The default is mainnet, which can be changed to testnet.

#### 

### Ecdsa

Ecdsa is the signature algorithm used by bitcoin. The way you probably want
to use this is with the static Ecdsa.sign( ... ) and Ecdsa.verify( ... )
functions. Note that in bitcoin, the hashBuf is little endian, so if you are
signing or verifying something that has to do with a transaction, you should
explicitly plug in that it is little endian as an option to the sign and
verify functions.

This implementation of Ecdsa uses deterministic signatures as defined in RFC
6979 as the default, which has become a defacto standard in bitcoin wallets
due to recurring security issues around using a value of k pulled from a
possibly faulty entropy pool. If you use the same value of k twice, someone
can derive your private key. Deterministic k prevents this without needing
an entropy pool.

#### deterministicK

The traditional Ecdsa algorithm uses a purely random value of k. This has
the negative that when signing, your entropy must be good, or the private
key can be recovered if two signatures use the same value of k. It turns out
that k does not have to be purely random. It can be deterministic, so long
as an attacker can't guess it. RFC 6979 specifies how to do this using a
combination of the private key and the hash of the thing to be signed. It is
best practice to use this value, which can be tested for byte-for-byte
accuracy, and is resistant to a broken RNG. Note that it is actually the
case that bitcoin private keys have been compromised through that attack.
Deterministic k is a best practice.

<https://tools.ietf.org/html/rfc6979#section-3.2>

##### Parameters

-   `badrs`  

#### sig2PubKey

Information about public key recovery:
<https://bitcointalk.org/index.php?topic=6430.0>
<http://stackoverflow.com/questions/19665491/how-do-i-get-an-ecdsa-public-key-from-just-a-bitcoin-signature-sec1-4-1-6-k>
This code was originally taken from BitcoinJS

#### calcrecovery

Calculates the recovery factor, and mutates sig so that it now contains
the recovery factor and the "compressed" variable. Throws an exception on
failure.

##### Parameters

-   `sig`  
-   `pubKey`  
-   `hashBuf`  

#### 

### Hash

Some hash functions are used through out bitcoin. We expose them here as a
convenience.

#### 

### Script Interpreter

Bitcoin transactions contain scripts. Each input has a script called the
scriptSig, and each output has a script called the scriptPubKey. To validate
an input, the ScriptSig is executed, then with the same stack, the
scriptPubKey from the output corresponding to that input is run. The primary
way to use this class is via the verify function:

new Interp().verify( ... )

In some ways, the script interpreter is one of the most poorly architected
components of Yours Bitcoin because of the giant switch statement in step(). But
that is deliberately so to make it similar to bitcoin core, and thus easier
to audit.

#### fromJSONNoTx

Convert JSON containing everything but the tx to an interp object.

##### Parameters

-   `json`  

#### toJSONNoTx

Convert everything but the tx to JSON.

#### checkSigEncoding

Translated from bitcoin core's CheckSigEncoding

##### Parameters

-   `buf`  

#### checkPubKeyEncoding

Translated from bitcoin core's CheckPubKeyEncoding

##### Parameters

-   `buf`  

#### checkLockTime

Translated from bitcoin core's CheckLockTime

##### Parameters

-   `nLockTime`  

#### checkSequence

Translated from bitcoin core's CheckSequence.

##### Parameters

-   `nSequence`  

#### eval

Based on bitcoin core's EvalScript function, with the inner loop moved to
Interp.prototype.step()
bitcoin core commit: b5d1b1092998bc95313856d535c632ea5a8f9104

#### step

Based on the inner loop of bitcoin core's EvalScript function

#### verify

This function has the same interface as bitcoin core's VerifyScript and is
the function you want to use to know if a particular input in a
transaction is valid or not. It simply iterates over the results generated
by the results method.

##### Parameters

-   `scriptSig`  
-   `scriptPubKey`  
-   `tx`  
-   `nIn`  
-   `flags`  
-   `valueBn`  

#### results

Gives you the results of the execution each operation of the scripSig and
scriptPubKey corresponding to a particular input (nIn) for the concerned
transaction (tx). Each result can be either true or false. If true, then
the operation did not invalidate the transaction. If false, then the
operation has invalidated the script, and the transaction is not valid.
flags is a number that can pass in some special flags, such as whether or
not to execute the redeemScript in a p2sh transaction.

This method is translated from bitcoin core's VerifyScript.  This function
is a generator, thus you can and need to iterate through it.  To
automatically return true or false, use the verify method.

##### Parameters

-   `scriptSig`  
-   `scriptPubKey`  
-   `tx`  
-   `nIn`  
-   `flags`  
-   `valueBn`  

#### getDebugObject

If the script has failed, this methods returns valuable debug
information about exactly where the script failed. It is a
JSON-compatible object so it can be easily stringified. pc refers to the
currently executing opcode.

#### getFlags

In order to make auduting the script interpreter easier, we use the same
constants as bitcoin core, including the flags, which customize the
operation of the interpreter.

##### Parameters

-   `flagstr`  

#### 

### KeyPair

A keyPair is a collection of a private key and a public key.
const keyPair = new KeyPair().fromRandom()
const keyPair = new KeyPair().fromPrivKey(privKey)
const privKey = keyPair.privKey
const pubKey = keyPair.pubKey

#### 

### Point (on secp256k1)

A point is a point on the secp256k1 curve which is the elliptic curve used
by bitcoin. This code is a wrapper for Fedor Indutny's Point class from his
elliptic library. This code adds a few minor conveniences, but is mostly the
same. Since Fedor's code returns points and big numbers that are instances
of his point and big number classes, we have to wrap all the methods such as
getX() to return the Yours Bitcoin point and big number types.

#### 

### Private Key

A private key is used for signing transactions (or messages). The primary
way to use this is new PrivKey().fromRandom(), or new PrivKey().fromBuffer(buf).

#### toWif

Output the private key a Wallet Import Format (Wif) string.

#### fromWif

Input the private key from a Wallet Import Format (Wif) string.

##### Parameters

-   `str`  

#### 

### Public Key

A public key corresponds to a private key. If you have a private key, you
can find the corresponding public key with new PubKey().fromPrivKey(privKey).

#### fromDer

In order to mimic the non-strict style of OpenSSL, set strict = false. For
information and what prefixes 0x06 and 0x07 mean, in addition to the normal
compressed and uncompressed public keys, see the message by Peter Wuille
where he discovered these "hybrid pubKeys" on the mailing list:
<http://sourceforge.net/p/bitcoin/mailman/message/29416133/>

##### Parameters

-   `buf`  
-   `strict`  

#### isCompressedOrUncompressed

Translated from bitcoind's IsCompressedOrUncompressedPubKey

##### Parameters

-   `buf`  

#### 

### Random Number Generator

Random numbers are important in bitcoin primarily for generating private
keys. It is also important for creating signatures if you are using a random
value of k, but Yours Bitcoin defaults to using deterministic k. That means
computing a random private key, or a random seed for use in Bip39 or Bip32,
is the primary use of the random number generator.  Note that the simplicity
of this class is extremely carefully considered. It is easy to audit that
this code runs node's randomBytes function. It is also easy to audit that
the randomBytes method is correctly interpreted as
window.crypto.getRandomValues when this code is browserified by browserify,
and thus also works correctly in the browser. We deliberately do not do
anything else to this random number in order to minimize possible errors in
this absolutely critical code.

#### fromBitcoindString

Input the script from the script string format used in bitcoind data tests

##### Parameters

-   `str`  

#### toBitcoindString

Output the script to the script string format used in bitcoind data tests.

#### fromAsmString

Input the script from the script string format used in bitcoind data tests

##### Parameters

-   `str`  

#### toAsmString

Output the script to the script string format used in bitcoind data tests.

#### fromPubKeyHash

Turn script into a standard pubKeyHash output script

##### Parameters

-   `hashBuf`  

#### fromPubKeys

Generate a multisig output script from a list of public keys. sort
defaults to true. If sort is true, the pubKeys are sorted
lexicographically.

##### Parameters

-   `m`  
-   `pubKeys`  
-   `sort`   (optional, default `true`)

#### isPubKeyHashIn

A pubKeyHash input should consist of two push operations. The first push
operation may be OP_0, which means the signature is missing, which is true
for some partially signed (and invalid) transactions.

#### isScriptHashIn

Note that these are frequently indistinguishable from pubKeyHashin

#### findAndDelete

Analagous to bitcoind's FindAndDelete Find and deconste equivalent chunks,
typically used with push data chunks.  Note that this will find and deconste
not just the same data, but the same data with the same push data op as
produced by default. i.e., if a pushdata in a tx does not use the minimal
pushdata op, then when you try to remove the data it is pushing, it will not
be removed, because they do not use the same pushdata op.

##### Parameters

-   `script`  

#### 

### Signature

A signature is the thing you make when you want to sign a transaction, or
the thing you want to verify if you want to ensure that someone signed a
transaction. It has an r and s value, which are the cryptographic big
numbers that define a signature. And since this is a bitcoin library, it
also has nHashType, which is the way to hash a transaction and is used in
the binary format of a signature when it is in a transaction. We also
support a public key recover value, recovery, allowing one to compute the
public key from a signature. The "compressed" value is also necessary to
accurately compute the public key from a signature.

There are a few different formats of a signature in bitcoin. One is DER, the
other is the TxFormat which is the same as DER but with the nHashType byte
appended, and the final one is Compact, which is used by Bitcoin Signed
Message (Bsm).

#### Sig

**Extends Struct**

r, s: big numbers constiting a cryptographic signature
nHashType: found at the end of a signature in a transaction
recovery: public key recovery number
compressed: whether the recovered pubKey is compressed

##### Parameters

-   `r`  
-   `s`  
-   `nHashType`  
-   `recovery`  
-   `compressed`  

##### hasLowS

Compares to bitcoind's IsLowDERSignature
See also Ecdsa signature algorithm which enforces this.
See also Bip 62, "low S values in signatures"

##### hasDefinedHashType

Ensures the nHashType is exactly equal to one of the standard options or combinations thereof.
Translated from bitcoind's IsDefinedHashtypeSignature

##### parseDer

In order to mimic the non-strict DER encoding of OpenSSL, set strict = false.

###### Parameters

-   `buf`  
-   `strict`  

##### IsTxDer

This function is translated from bitcoind's IsDERSignature and is used in
the script interpreter.  This "DER" format actually includes an extra byte,
the nHashType, at the end. It is really the tx format, not DER format.

A canonical signature exists of: [30][total len] [02][len r] [R][02] [len S][s] [hashtype]
Where R and S are not negative (their first byte has its highest bit not set), and not
excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,
in which case a single 0 byte is necessary and even required).

See <https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623>

###### Parameters

-   `buf`  

#### 

### PubKey Map

A map from (transaction hash, output number) to (script chunk index, pubKey).
Whening signing a bitcoin transaction, we need to be able to sign an input
with the correct key and also we need to know where to put signature when we
get it. This mapping allows us to find the key for an associated input (which
is identified by tx output hash and number) with which to sign the
transaction and then also to know where to insert the signature into the
input script. This gets us the public key, and we need a different method to
get the private key. That is because we often know the public key to be used
but may not have access to the private key until the entire tx is sent to
where the private keys are.

#### setOne

Set an address to in the map for use with single-sig.

##### Parameters

-   `txHashBuf` **[Buffer](https://nodejs.org/api/buffer.html)** The hash of a transsaction. Note that this is
    _not_ the reversed transaction id, but is the raw hash.
-   `txOutNum` **[Number](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number)** The output number, a.k.a. the "vout".
-   `nScriptChunk` **[Number](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number)** The index of the chunk of the script where
    we are going to place the signature.
-   `type`   (optional, default `'sig'`)
-   `addressStr` **[String](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String)** The addressStr coresponding to this (txHashBuf,
    txOutNum, nScriptChunk) where we are going to sign and insert the
    signature or public key.
-   `nHashType` **[Number](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number)** Usually = Sig.SIGHASH_ALL | Sig.SIGHASH_FORKID (optional, default `Sig.SIGHASH_ALL|Sig.SIGHASH_FORKID`)

#### setMany

Set a bunch of addresses for signing an input such as for use with multi-sig.

##### Parameters

-   `txHashBuf` **[Buffer](https://nodejs.org/api/buffer.html)** The hash of a transsaction. Note that this is
    _not_ the reversed transaction id, but is the raw hash.
-   `txOutNum` **[Number](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number)** The output number, a.k.a. the "vout".
-   `arr` **[Array](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array)** Must take the form of [{nScriptChunk, type, addressStr, nHashType}, ...]

#### get

Get an address from the map

##### Parameters

-   `txHashBuf` **[Buffer](https://nodejs.org/api/buffer.html)** The hash of a transction. Note that this is _not_
    the reversed transaction id, but is the raw hash.
-   `txOutNum` **[Number](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number)** The output number, a.k.a. the "vout".
-   `nScriptChunk` **[Number](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number)** The index of the chunk of the script where
    we are going to place the signature.

Returns **PubKey** 

#### 

### Structure

A convenient structure to extend objects from that comes with very common
boiler plate instance methods:

-   fromObject
-   fromBr
-   toBw
-   fromBuffer
-   fromFastBuffer
-   toBuffer
-   toFastBuffer
-   fromHex
-   toHex
-   fromString
-   toString
-   fromJSON
-   toJSON
-   cloneByBuffer
-   cloneByFastBuffer
-   cloneByHex
-   cloneByString
-   cloneByJSON

As well as static methods for:

-   fromObject
-   fromBr
-   fromBuffer
-   fromFastBuffer
-   fromHex
-   fromString
-   fromJSON

The "expect" method also facilitates deserializing a sequence of buffers
into an object.

#### genFromBuffers

It is very often the case that you want to create a bitcoin object from a
stream of small buffers rather than from a buffer of the correct length.
For instance, if streaming from the network or disk. The genFromBuffers
method is a generator which produces an iterator. Use .next(buf) to pass
in a small buffer. The iterator will end when it has received enough data
to produce the object. In some cases it is able to yield the number of
bytes it is expecting, but that is not always known.

#### expect

A convenience method used by from the genFromBuffers\* generators.
Basically lets you expect a certain number of bytes (len) and keeps
yielding until you give it enough. It yields the expected amount
remaining, and returns an object containing a buffer of the expected
length, and, if any, the remainder buffer.

##### Parameters

-   `len`  
-   `startbuf`  

#### fromBuffer

Convert a buffer into an object, i.e. deserialize the object.

##### Parameters

-   `buf`  
-   `rest` **...any** 

#### fromFastBuffer

The complement of toFastBuffer - see description for toFastBuffer

##### Parameters

-   `buf`  
-   `rest` **...any** 

#### toBuffer

Convert the object into a buffer, i.e. serialize the object. This method
may block the main thread.

##### Parameters

-   `rest` **...any** 

#### toFastBuffer

Sometimes the toBuffer method has cryptography and blocks the main thread,
and we need a non-blocking way to serialize an object. That is what
toFastBuffer is. Of course it defaults to just using toBuffer if an object
hasn't implemented it. If your regular toBuffer method blocks, like with
Bip32, then you should implement this method to be non-blocking. This
method is used to send objects to the workers. i.e., for converting a
Bip32 object to a string, we need to encode it as a buffer in a
non-blocking manner with toFastBuffer, send it to a worker, then the
worker converts it to a string, which is a blocking operation.

It is very common to want to convert a blank object to a zero length
buffer, so we can transport a blank object to a worker. So that behavior
is included by default.

##### Parameters

-   `rest` **...any** 

#### 

### Transaction

A bitcoin transaction.

#### sighash

For a normal transaction, subScript is usually the scriptPubKey. For a
p2sh transaction, subScript is usually the redeemScript. If you're not
normal because you're using OP_CODESEPARATORs, you know what to do.

##### Parameters

-   `nHashType`  
-   `nIn`  
-   `subScript`  
-   `valueBn`  
-   `flags`   (optional, default `0`)
-   `hashCache`   (optional, default `new HashCache()`)

#### isCoinbase

Analagous to bitcoind's IsCoinBase function in transaction.h

#### sort

BIP 69 sorting. Be sure to sign after sorting.

#### 

### Hash Cache

For use in sighash.

#### 

### Transaction Builder

#### setNLocktime

nLockTime is an unsigned integer.

##### Parameters

-   `nLockTime`  

#### setDust

Sometimes one of your outputs or the change output will be less than
dust. Values less than dust cannot be broadcast. If you are OK with
sending dust amounts to fees, then set this value to true.

##### Parameters

-   `dust`   (optional, default `Constants.dust`)

#### sendDustChangeToFees

Sometimes one of your outputs or the change output will be less than
dust. Values less than dust cannot be broadcast. If you are OK with
sending dust amounts to fees, then set this value to true. We
preferentially send all dust to the change if possible. However, that
might not be possible if the change itself is less than dust, in which
case all dust goes to fees.

##### Parameters

-   `dustChangeToFees`   (optional, default `false`)

#### importPartiallySignedTx

Import a transaction partially signed by someone else. The only thing you
can do after this is sign one or more inputs. Usually used for multisig
transactions. uTxOutMap is optional. It is not necessary so long as you
pass in the txOut when you sign. You need to know the output when signing
an input, including the script in the output, which is why this is
necessary when signing an input.

##### Parameters

-   `tx`  
-   `uTxOutMap`   (optional, default `this.uTxOutMap`)
-   `sigOperations`   (optional, default `this.sigOperations`)

#### inputFromScript

Pay "from" a script - in other words, add an input to the transaction.

##### Parameters

-   `txHashBuf`  
-   `txOutNum`  
-   `txOut`  
-   `script`  
-   `nSequence`  

#### inputFromPubKeyHash

Pay "from" a pubKeyHash output - in other words, add an input to the
transaction.

##### Parameters

-   `txHashBuf`  
-   `txOutNum`  
-   `txOut`  
-   `pubKey`  
-   `nSequence`  
-   `nHashType`  

#### outputToAddress

An address to send funds to, along with the amount. The amount should be
denominated in satoshis, not bitcoins.

##### Parameters

-   `valueBn`  
-   `addr`  

#### outputToScript

A script to send funds to, along with the amount. The amount should be
denominated in satoshis, not bitcoins.

##### Parameters

-   `valueBn`  
-   `script`  

#### build

Builds the transaction and adds the appropriate fee by subtracting from
the change output. Note that by default the TxBuilder will use as many
inputs as necessary to pay the output amounts and the required fee. The
TxBuilder will not necessarily us all the inputs. To force the TxBuilder
to use all the inputs (such as if you wish to spend the entire balance
of a wallet), set the argument useAllInputs = true.

##### Parameters

-   `opts`   (optional, default `{useAllInputs:false}`)

#### getSig

Sign an input, but do not fill the signature into the transaction. Return
the signature.

For a normal transaction, subScript is usually the scriptPubKey. If
you're not normal because you're using OP_CODESEPARATORs, you know what
to do.

##### Parameters

-   `keyPair`  
-   `nHashType`   (optional, default `Sig.SIGHASH_ALL|Sig.SIGHASH_FORKID`)
-   `nIn`  
-   `subScript`  
-   `flags`   (optional, default `Tx.SCRIPT_ENABLE_SIGHASH_FORKID`)

#### asyncGetSig

Asynchronously sign an input in a worker, but do not fill the signature
into the transaction. Return the signature.

##### Parameters

-   `keyPair`  
-   `nHashType`   (optional, default `Sig.SIGHASH_ALL|Sig.SIGHASH_FORKID`)
-   `nIn`  
-   `subScript`  
-   `flags`   (optional, default `Tx.SCRIPT_ENABLE_SIGHASH_FORKID`)

#### signTxIn

Sign ith input with keyPair and insert the signature into the transaction.
This method only works for some standard transaction types. For
non-standard transaction types, use getSig.

##### Parameters

-   `nIn`  
-   `keyPair`  
-   `txOut`  
-   `nScriptChunk`  
-   `nHashType`   (optional, default `Sig.SIGHASH_ALL|Sig.SIGHASH_FORKID`)
-   `flags`   (optional, default `Tx.SCRIPT_ENABLE_SIGHASH_FORKID`)

#### asyncSignTxIn

Asynchronously sign ith input with keyPair in a worker and insert the
signature into the transaction.  This method only works for some standard
transaction types. For non-standard transaction types, use asyncGetSig.

##### Parameters

-   `nIn`  
-   `keyPair`  
-   `txOut`  
-   `nScriptChunk`  
-   `nHashType`   (optional, default `Sig.SIGHASH_ALL|Sig.SIGHASH_FORKID`)
-   `flags`   (optional, default `Tx.SCRIPT_ENABLE_SIGHASH_FORKID`)

#### allSigsPresent

Check if all signatures are present in a multisig input script.

##### Parameters

-   `m`  
-   `script`  

#### removeBlankSigs

Remove blank signatures in a multisig input script.

##### Parameters

-   `script`  

#### fromPubKeyHashTxOut

Generate txIn with blank signatures from a txOut and its
txHashBuf+txOutNum. A "blank" signature is just an OP_0. The pubKey also
defaults to blank but can be substituted with the real public key if you
know what it is.

##### Parameters

-   `txHashBuf`  
-   `txOutNum`  
-   `txOut`  
-   `pubKey`  

#### setNullInput

Analagous to bitcoind's SetNull in COutPoint

#### 

### Transaction Output

An output to a transaction. The way you normally want to make one is with
new TxOut(valueBn, script) (i.e., just as with TxIn, you can leave out the
scriptVi, since it can be computed automatically.

#### 

### Transaction Output Map

A map from a transaction hash and output number to that particular output.
Note that the map is from the transaction _hash_, which is the value that
occurs in the blockchain, not the id, which is the reverse of the hash. The
TxOutMap is necessary when signing a transction to get the script and value
of that output which is plugged into the sighash algorithm.

#### 

### Transaction Verifier

#### verify

Verifies that the transaction is valid both by performing basic checks, such
as ensuring that no two inputs are the same, as well as by verifying every
script. The two checks are checkStr, which is analagous to bitcoind's
CheckTransaction, and verifyStr, which runs the script interpreter.

This does NOT check that any possible claimed fees are accurate; checking
that the fees are accurate requires checking that the input transactions are
valid, which is not performed by this test. That check is done with the
normal verify function.

##### Parameters

-   `flags`   (optional, default `Interp.SCRIPT_ENABLE_SIGHASH_FORKID`)

#### checkStr

Check that a transaction passes basic sanity tests. If not, return a string
describing the error. This function contains the same logic as
CheckTransaction in bitcoin core.

#### verifyStr

verify the transaction inputs by running the script interpreter. Returns a
string of the script interpreter is invalid, otherwise returns false.

##### Parameters

-   `flags`  

#### verifyNIn

Verify a particular input by running the script interpreter. Returns true if
the input is valid, false otherwise.

##### Parameters

-   `nIn`  
-   `flags`  

#### verify

Convenience method to verify a transaction.

##### Parameters

-   `tx`  
-   `txOutMap`  
-   `flags`  

#### 

### VarInt (a.k.a. Compact Size)

A varInt is a varible sized integer, and it is a format that is unique to
bitcoin, and used throughout bitcoin to represent the length of binary data
in a compact format that can take up as little as 1 byte or as much as 9
bytes.

#### 

### Workers

Workers manages either processes (in node) or threads (in a browser). The
workers are intended to handle CPU-heavy tasks that block IO. This class is
a little unusual in that it must use different interfaces whether in node or
in the browser. In node, we use node's build-in child_process fork to create
new workers we can communicate with. In the browser, we use web workers.
Unfortunately, node and web browsers do not have a common interface for
workers. There is a node module called webworker-threads for node that
mimics the browser's web workers, but unfortunately it does not support
require(), and thus isn't very useful in our case. Therefore we fall back to
process forks.

You probably don't need to use this class directly. Use Work, which will
automatically spawn new workers if needed.

#### 

### WorkersResult

A response sent back from a worker to the main thread. Contains the "result"
of the computation in the form of a buffer, resbuf. If the actual result is
an object with a .toFastBuffer method, the object is converted to a buffer
using that method. Otherwise it is JSON serialized into a buffer. The result
can also be an error, in which case the isError flag is set.

#### 

### Constant-Time Buffer Compare

A constant-time comparison function. This should be used in any security
sensitive code where leaking timing information may lead to lessened
security. Note that if the buffers are not equal in length, this function
loops for the longest buffer, which may not be necessary. Usually this
function should be used for buffers that would otherwise be equal length,
such as a hash, particularly Hmacs.

The algorithm here, which is XORs each byte (or, if undefined, 0) with the
corresponding other byte, and then ORs that with a running total (d), is
adapted from here:

<https://groups.google.com/forum/#!topic/keyczar-discuss/VXHsoJSLKhM>

#### 

### Ach (Aes+Cbc+Hmac) (experimental)

An "encrypt-then-MAC" that uses Aes, Cbc and SHA256 Hmac. This is suitable
for general encryption of data.

The encrypted data takes the form:
(256 bit hmac)(128 bit iv)(128+ bits Aes+Cbc encrypted message)

#### 

### Aes (experimental)

Advanced Encryption Standard (Aes). This is a low-level tool for encrypting
or decrypting blocks of data. There is almost never a reason to use this -
don't use it unless you need to encrypt or decrypt individual blocks.

#### 

### Aescbc (experimental)

This is a convenience class for using Aes with Cbc. This is a low-level tool
that does not include authentication. You should only use this if you are
authenticating your data somehow else.

#### 

### Cbc

Cipher Block Chaining (Cbc). This is a low-level tool for chaining multiple
encrypted blocks together, usually with Aes. This is a low-level tool that
does not include authentication. You should only be using this if you have
authentication at another step. It is best combined with Hmac.

[http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher-block_chaining_.28Cbc.29](http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher-block_chaining_.28Cbc.29)

#### 

### Ecies

## Goals

bsv is a javascript library for Bitcoin SV (BSV) intended to satisfy certain
goals:

1.  Support ease-of-use by being internally consistent. It should not be
    necessary to read the source code of a class or function to know how to use it.
    Once you know how to use part of the library, the other parts should feel
    natural.

2.  Have 100% test coverage, or nearly so, so that the library is known to be
    reliable. This should include running standard test vectors from the reference
    implementation.

3.  Library objects have an interface suitable for use with a command-line
    interface or other libraries and tools, in particular having toString,
    fromString, toJSON, fromJSON, toBuffer, fromBuffer, toHex, fromHex methods.

4.  All standard features of the blockchain are implemented (or will be) and
    saved in lib/. All BIPs are correctly implemented and, where appropriate, saved
    as bip-xx.js in lib/ (since that is their standard name). In order to allow
    rapid development, Yours Bitcoin includes non-standard and experimental
    features. Any non-standard features (such as colored coins or stealth
    addresses) are labeled as such in index.js as well as in comments.

5.  Expose everything, including dependencies. This makes it possible to develop
    apps that require fine-grained control over the basics, such as big numbers and
    points. However, it also means that you can hurt yourself if you misuse these
    primitives.

6.  Use standard javascript conventions wherever possible so that other
    developers find the code easy to understand.

7.  Minimize the use of dependencies so that all code can be easily audited.

8.  All instance methods modify the state of the object and return the object,
    unless there is a good reason to do something different. To access the result
    of an instance method, you must access the object property(s) that it modifies.

9.  Support web workers to unblock web wallet UIs when performing cryptography.

## Environment Variables

-   `BSV_JS_BASE_URL` - Default "/".
-   `BSV_JS_BUNDLE_FILE` - Default "bsv.js"
-   `BSV_JS_WORKER_FILE` - Default "bsv-worker.js"
-   `NETWORK` - Default "mainnet"

You can change the network to run the CLI in testnet mode:

    NETWORK=testnet ./bin/bsv.js
