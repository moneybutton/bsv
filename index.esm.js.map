{"version":3,"file":"index.esm.js","sources":["lib/bn.js"],"sourcesContent":["/**\n * Big Number\n * ==========\n *\n * Since javascript numbers are only precise up to 53 bits, and bitcoin is\n * based on cryptography that uses 256 bit numbers, we must use a big number\n * library. The library we use at the moment is Fedor Indutny's bn.js library.\n * Since big numbers are extremely useful, we provide some very basic wrappers\n * for his big number class and expose it. The wrappers merely allow you to do,\n * say, bn.cmp(num) instead of just bn.cmp(bn), which is nice. The primary way\n * to use this is:\n * let bn = Bn(str) // str is base 10\n * let bn = Bn(num)\n * let bn = Bn().fromBuffer(buf)\n * let bn = Bn().fromSm(buf); // sign+magnitude format, first bit is sign\n *\n * For little endian, pass in an options value:\n * let bn = Bn().fromBuffer(buf, {endian: 'little'})\n * let bn = Bn().fromSm(buf, {endian: 'little'})\n *\n * Getting output:\n * let str = Bn().toString() // produces base 10 string\n * let buf = Bn().toBuffer() // produces buffer representation\n * let buf = Bn().toBuffer({size: 32}) //produced 32 byte buffer\n */\n'use strict'\n\nimport _Bn from 'bn.js'\n\nfunction Bn (n, base, ...rest) {\n  if (!(this instanceof Bn)) {\n    return new Bn(n, base, ...rest)\n  }\n  _Bn.call(this, n, base, ...rest)\n}\n\nObject.keys(_Bn).forEach(function (key) {\n  Bn[key] = _Bn[key]\n})\nBn.prototype = Object.create(_Bn.prototype)\nBn.prototype.constructor = Bn\n\nfunction reverseBuf (buf) {\n  let buf2 = Buffer.alloc(buf.length)\n  for (let i = 0; i < buf.length; i++) {\n    buf2[i] = buf[buf.length - 1 - i]\n  }\n  return buf2\n}\n\nBn.prototype.fromHex = function (hex, opts) {\n  return this.fromBuffer(Buffer.from(hex, 'hex'), opts)\n}\n\nBn.prototype.toHex = function (opts) {\n  return this.toBuffer(opts).toString('hex')\n}\n\nBn.prototype.toJSON = function () {\n  return this.toString()\n}\n\nBn.prototype.fromJSON = function (str) {\n  let bn = Bn(str)\n  bn.copy(this)\n  return this\n}\n\nBn.prototype.fromNumber = function (n) {\n  let bn = Bn(n)\n  bn.copy(this)\n  return this\n}\n\nBn.prototype.toNumber = function () {\n  return parseInt(this['toString'](10), 10)\n}\n\nBn.prototype.fromString = function (str, base) {\n  let bn = Bn(str, base)\n  bn.copy(this)\n  return this\n}\n\nBn.fromBuffer = function (buf, opts = { endian: 'big' }) {\n  if (opts.endian === 'little') {\n    buf = reverseBuf(buf)\n  }\n  let hex = buf.toString('hex')\n  let bn = new Bn(hex, 16)\n  return bn\n}\n\nBn.prototype.fromBuffer = function (buf, opts) {\n  let bn = Bn.fromBuffer(buf, opts)\n  bn.copy(this)\n\n  return this\n}\n\nBn.prototype.toBuffer = function (opts = { size: undefined, endian: 'big' }) {\n  let buf\n  if (opts.size) {\n    let hex = this.toString(16, 2)\n    let natlen = hex.length / 2\n    buf = Buffer.from(hex, 'hex')\n\n    if (natlen === opts.size) {\n      // pass\n    } else if (natlen > opts.size) {\n      buf = buf.slice(natlen - buf.length, buf.length)\n    } else if (natlen < opts.size) {\n      let rbuf = Buffer.alloc(opts.size)\n      for (let i = 0; i < buf.length; i++) {\n        rbuf[rbuf.length - 1 - i] = buf[buf.length - 1 - i]\n      }\n      for (let i = 0; i < opts.size - natlen; i++) {\n        rbuf[i] = 0\n      }\n      buf = rbuf\n    }\n  } else {\n    let hex = this.toString(16, 2)\n    buf = Buffer.from(hex, 'hex')\n  }\n\n  if (opts.endian === 'little') {\n    buf = reverseBuf(buf)\n  }\n  let longzero = Buffer.from([0])\n  if (Buffer.compare(buf, longzero) === 0) {\n    return Buffer.from([])\n  }\n  return buf\n}\n\nBn.prototype.toFastBuffer = Bn.prototype.toBuffer\n\nBn.fromFastBuffer = Bn.fromBuffer\nBn.prototype.fromFastBuffer = Bn.prototype.fromBuffer\n\n/**\n   * Signed magnitude buffer. Most significant bit represents sign (0 = positive,\n   * 1 = negative).\n   */\nBn.prototype.fromSm = function (buf, opts = { endian: 'big' }) {\n  if (buf.length === 0) {\n    this.fromBuffer(Buffer.from([0]))\n  }\n\n  let endian = opts.endian\n  if (endian === 'little') {\n    buf = reverseBuf(buf)\n  }\n\n  if (buf[0] & 0x80) {\n    buf[0] = buf[0] & 0x7f\n    this.fromBuffer(buf)\n    this.neg().copy(this)\n  } else {\n    this.fromBuffer(buf)\n  }\n  return this\n}\n\nBn.prototype.toSm = function (opts = { endian: 'big' }) {\n  let endian = opts.endian\n\n  let buf\n  if (this.cmp(0) === -1) {\n    buf = this.neg().toBuffer()\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([Buffer.from([0x80]), buf])\n    } else {\n      buf[0] = buf[0] | 0x80\n    }\n  } else {\n    buf = this.toBuffer()\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([Buffer.from([0x00]), buf])\n    }\n  }\n\n  if ((buf.length === 1) & (buf[0] === 0)) {\n    buf = Buffer.from([])\n  }\n\n  if (endian === 'little') {\n    buf = reverseBuf(buf)\n  }\n\n  return buf\n}\n\n/**\n   * Produce a Bn from the \"bits\" value in a blockheader. Analagous to Bitcoin\n   * Core's uint256 SetCompact method. bits is assumed to be UInt32.\n   */\nBn.prototype.fromBits = function (bits, opts = { strict: false }) {\n  // To performed bitwise operations in javascript, we need to convert to a\n  // signed 32 bit value.\n  let buf = Buffer.alloc(4)\n  buf.writeUInt32BE(bits, 0)\n  bits = buf.readInt32BE(0)\n  if (opts.strict && bits & 0x00800000) {\n    throw new Error('negative bit set')\n  }\n  let nsize = bits >> 24\n  let nword = bits & 0x007fffff\n  buf = Buffer.alloc(4)\n  buf.writeInt32BE(nword)\n  if (nsize <= 3) {\n    buf = buf.slice(1, nsize + 1)\n  } else {\n    let fill = Buffer.alloc(nsize - 3)\n    fill.fill(0)\n    buf = Buffer.concat([buf, fill])\n  }\n  this.fromBuffer(buf)\n  if (bits & 0x00800000) {\n    Bn(0)\n      .sub(this)\n      .copy(this)\n  }\n  return this\n}\n\n/**\n   * Convert Bn to the \"bits\" value in a blockheader. Analagous to Bitcoin\n   * Core's uint256 GetCompact method. bits is a UInt32.\n   */\nBn.prototype.toBits = function () {\n  let buf\n  if (this.lt(0)) {\n    buf = this.neg().toBuffer()\n  } else {\n    buf = this.toBuffer()\n  }\n  let nsize = buf.length\n  let nword\n  if (nsize > 3) {\n    nword = Buffer.concat([Buffer.from([0]), buf.slice(0, 3)]).readUInt32BE(0)\n  } else if (nsize <= 3) {\n    let blank = Buffer.alloc(3 - nsize + 1)\n    blank.fill(0)\n    nword = Buffer.concat([blank, buf.slice(0, nsize)]).readUInt32BE(0)\n  }\n  if (nword & 0x00800000) {\n    // The most significant bit denotes sign. Do not want unless number is\n    // actually negative.\n    nword >>= 8\n    nsize++\n  }\n  if (this.lt(0)) {\n    nword |= 0x00800000\n  }\n  let bits = (nsize << 24) | nword\n  // convert bits to UInt32 before returnIng\n  buf = Buffer.alloc(4)\n  buf.writeInt32BE(bits, 0)\n  return buf.readUInt32BE(0)\n}\n\n// This is analogous to the constructor for CScriptNum in bitcoind. Many ops\n// in bitcoind's script interpreter use CScriptNum, which is not really a\n// proper bignum. Instead, an error is thrown if trying to input a number\n// bigger than 4 bytes. We copy that behavior here. There is one exception -\n// in CHECKLOCKTIMEVERIFY, the numbers are allowed to be up to 5 bytes long.\n// We allow for setting that variable here for use in CHECKLOCKTIMEVERIFY.\nBn.prototype.fromScriptNumBuffer = function (\n  buf,\n  fRequireMinimal,\n  nMaxNumSize\n) {\n  if (nMaxNumSize === undefined) {\n    nMaxNumSize = 4\n  }\n  if (buf.length > nMaxNumSize) {\n    throw new Error('script number overflow')\n  }\n  if (fRequireMinimal && buf.length > 0) {\n    // Check that the number is encoded with the minimum possible\n    // number of bytes.\n    //\n    // If the most-significant-byte - excluding the sign bit - is zero\n    // then we're not minimal. Note how this test also rejects the\n    // negative-zero encoding, 0x80.\n    if ((buf[buf.length - 1] & 0x7f) === 0) {\n      // One exception: if there's more than one byte and the most\n      // significant bit of the second-most-significant-byte is set\n      // it would conflict with the sign bit. An example of this case\n      // is +-255, which encode to 0xff00 and 0xff80 respectively.\n      // (big-endian).\n      if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {\n        throw new Error('non-minimally encoded script number')\n      }\n    }\n  }\n  return this.fromSm(buf, { endian: 'little' })\n}\n\n// The corollary to the above, with the notable exception that we do not throw\n// an error if the output is larger than four bytes. (Which can happen if\n// performing a numerical operation that results in an overflow to more than 4\n// bytes).\nBn.prototype.toScriptNumBuffer = function (buf) {\n  return this.toSm({ endian: 'little' })\n}\n\nBn.prototype.neg = function () {\n  let _neg = _Bn.prototype.neg.call(this)\n  let neg = Object.create(Bn.prototype)\n  _neg.copy(neg)\n  return neg\n}\n\nBn.prototype.add = function (bn) {\n  let _bn = _Bn.prototype.add.call(this, bn)\n  bn = Object.create(Bn.prototype)\n  _bn.copy(bn)\n  return bn\n}\n\nBn.prototype.sub = function (bn) {\n  let _bn = _Bn.prototype.sub.call(this, bn)\n  bn = Object.create(Bn.prototype)\n  _bn.copy(bn)\n  return bn\n}\n\nBn.prototype.mul = function (bn) {\n  let _bn = _Bn.prototype.mul.call(this, bn)\n  bn = Object.create(Bn.prototype)\n  _bn.copy(bn)\n  return bn\n}\n\n/**\n   * to be used if this is positive.\n   */\nBn.prototype.mod = function (bn) {\n  let _bn = _Bn.prototype.mod.call(this, bn)\n  bn = Object.create(Bn.prototype)\n  _bn.copy(bn)\n  return bn\n}\n\n/**\n   * to be used if this is negative.\n   */\nBn.prototype.umod = function (bn) {\n  let _bn = _Bn.prototype.umod.call(this, bn)\n  bn = Object.create(Bn.prototype)\n  _bn.copy(bn)\n  return bn\n}\n\nBn.prototype.invm = function (bn) {\n  let _bn = _Bn.prototype.invm.call(this, bn)\n  bn = Object.create(Bn.prototype)\n  _bn.copy(bn)\n  return bn\n}\n\nBn.prototype.div = function (bn) {\n  let _bn = _Bn.prototype.div.call(this, bn)\n  bn = Object.create(Bn.prototype)\n  _bn.copy(bn)\n  return bn\n}\n\nBn.prototype.cmp = function (bn) {\n  return _Bn.prototype.cmp.call(this, bn)\n}\n\n/**\n   * All the standard big number operations operate on other big numbers. e.g.,\n   * bn1.add(bn2). But it is frequenly valuble to add numbers or strings, e.g.\n   * bn.add(5) or bn.add('5'). The decorator wraps all methods where this would\n   * be convenient and makes that possible.\n   */\nfunction decorate (name) {\n  Bn.prototype['_' + name] = Bn.prototype[name]\n  let f = function (b) {\n    if (typeof b === 'string') {\n      b = new Bn(b)\n    } else if (typeof b === 'number') {\n      b = new Bn(b.toString())\n    }\n    return this['_' + name](b)\n  }\n  Bn.prototype[name] = f\n}\n\nBn.prototype.eq = function (b) {\n  return this.cmp(b) === 0\n}\n\nBn.prototype.neq = function (b) {\n  return this.cmp(b) !== 0\n}\n\nBn.prototype.gt = function (b) {\n  return this.cmp(b) > 0\n}\n\nBn.prototype.geq = function (b) {\n  return this.cmp(b) >= 0\n}\n\nBn.prototype.lt = function (b) {\n  return this.cmp(b) < 0\n}\n\nBn.prototype.leq = function (b) {\n  return this.cmp(b) <= 0\n}\n\ndecorate('add')\ndecorate('sub')\ndecorate('mul')\ndecorate('mod')\ndecorate('invm')\ndecorate('div')\ndecorate('cmp')\ndecorate('gt')\ndecorate('geq')\ndecorate('lt')\ndecorate('leq')\n\nexport { Bn }\n"],"names":["Bn","n","base","rest","this","_Bn","call","reverseBuf","buf","buf2","Buffer","alloc","length","i","decorate","name","prototype","b","toString","Object","keys","forEach","key","create","constructor","fromHex","hex","opts","fromBuffer","from","toHex","toBuffer","toJSON","fromJSON","str","copy","fromNumber","toNumber","parseInt","fromString","endian","toFastBuffer","size","undefined","natlen","slice","rbuf","longzero","compare","fromFastBuffer","fromSm","neg","toSm","cmp","concat","fromBits","bits","strict","writeUInt32BE","readInt32BE","Error","nsize","nword","writeInt32BE","fill","sub","toBits","lt","readUInt32BE","blank","fromScriptNumBuffer","fRequireMinimal","nMaxNumSize","toScriptNumBuffer","_neg","add","bn","_bn","mul","mod","umod","invm","div","eq","neq","gt","geq","leq"],"mappings":"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"}